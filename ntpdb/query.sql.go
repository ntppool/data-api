// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package ntpdb

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getMonitorByNameAndIPVersion = `-- name: GetMonitorByNameAndIPVersion :one
select id, id_token, type, user_id, account_id, hostname, location, ip, ip_version, tls_name, api_key, status, config, client_version, last_seen, last_submit, created_on, deleted_on, is_current from monitors
where
  tls_name like ? AND
  ip_version = ? AND
  is_current = 1 AND
  status != 'deleted'
  order by id
  limit 1
`

type GetMonitorByNameAndIPVersionParams struct {
	TlsName   sql.NullString        `db:"tls_name" json:"tls_name"`
	IpVersion NullMonitorsIpVersion `db:"ip_version" json:"ip_version"`
}

func (q *Queries) GetMonitorByNameAndIPVersion(ctx context.Context, arg GetMonitorByNameAndIPVersionParams) (Monitor, error) {
	row := q.db.QueryRowContext(ctx, getMonitorByNameAndIPVersion, arg.TlsName, arg.IpVersion)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.IDToken,
		&i.Type,
		&i.UserID,
		&i.AccountID,
		&i.Hostname,
		&i.Location,
		&i.Ip,
		&i.IpVersion,
		&i.TlsName,
		&i.ApiKey,
		&i.Status,
		&i.Config,
		&i.ClientVersion,
		&i.LastSeen,
		&i.LastSubmit,
		&i.CreatedOn,
		&i.DeletedOn,
		&i.IsCurrent,
	)
	return i, err
}

const getMonitorsByID = `-- name: GetMonitorsByID :many
select id, id_token, type, user_id, account_id, hostname, location, ip, ip_version, tls_name, api_key, status, config, client_version, last_seen, last_submit, created_on, deleted_on, is_current from monitors
where id in (/*SLICE:MonitorIDs*/?)
`

func (q *Queries) GetMonitorsByID(ctx context.Context, monitorids []uint32) ([]Monitor, error) {
	query := getMonitorsByID
	var queryParams []interface{}
	if len(monitorids) > 0 {
		for _, v := range monitorids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:MonitorIDs*/?", strings.Repeat(",?", len(monitorids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:MonitorIDs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.IDToken,
			&i.Type,
			&i.UserID,
			&i.AccountID,
			&i.Hostname,
			&i.Location,
			&i.Ip,
			&i.IpVersion,
			&i.TlsName,
			&i.ApiKey,
			&i.Status,
			&i.Config,
			&i.ClientVersion,
			&i.LastSeen,
			&i.LastSubmit,
			&i.CreatedOn,
			&i.DeletedOn,
			&i.IsCurrent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServerByID = `-- name: GetServerByID :one
select id, ip, ip_version, user_id, account_id, hostname, stratum, in_pool, in_server_list, netspeed, netspeed_target, created_on, updated_on, score_ts, score_raw, deletion_on, flags from servers
where
  id = ?
`

func (q *Queries) GetServerByID(ctx context.Context, id uint32) (Server, error) {
	row := q.db.QueryRowContext(ctx, getServerByID, id)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.IpVersion,
		&i.UserID,
		&i.AccountID,
		&i.Hostname,
		&i.Stratum,
		&i.InPool,
		&i.InServerList,
		&i.Netspeed,
		&i.NetspeedTarget,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ScoreTs,
		&i.ScoreRaw,
		&i.DeletionOn,
		&i.Flags,
	)
	return i, err
}

const getServerByIP = `-- name: GetServerByIP :one
select id, ip, ip_version, user_id, account_id, hostname, stratum, in_pool, in_server_list, netspeed, netspeed_target, created_on, updated_on, score_ts, score_raw, deletion_on, flags from servers
where
  ip = ?
`

func (q *Queries) GetServerByIP(ctx context.Context, ip string) (Server, error) {
	row := q.db.QueryRowContext(ctx, getServerByIP, ip)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.IpVersion,
		&i.UserID,
		&i.AccountID,
		&i.Hostname,
		&i.Stratum,
		&i.InPool,
		&i.InServerList,
		&i.Netspeed,
		&i.NetspeedTarget,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ScoreTs,
		&i.ScoreRaw,
		&i.DeletionOn,
		&i.Flags,
	)
	return i, err
}

const getServerLogScores = `-- name: GetServerLogScores :many
select id, monitor_id, server_id, ts, score, step, offset, rtt, attributes from log_scores
where
  server_id = ?
  order by ts desc
  limit ?
`

type GetServerLogScoresParams struct {
	ServerID uint32 `db:"server_id" json:"server_id"`
	Limit    int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetServerLogScores(ctx context.Context, arg GetServerLogScoresParams) ([]LogScore, error) {
	rows, err := q.db.QueryContext(ctx, getServerLogScores, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogScore
	for rows.Next() {
		var i LogScore
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.ServerID,
			&i.Ts,
			&i.Score,
			&i.Step,
			&i.Offset,
			&i.Rtt,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServerLogScoresByMonitorID = `-- name: GetServerLogScoresByMonitorID :many
select id, monitor_id, server_id, ts, score, step, offset, rtt, attributes from log_scores
where
  server_id = ? AND
  monitor_id = ?
  order by ts desc
  limit ?
`

type GetServerLogScoresByMonitorIDParams struct {
	ServerID  uint32        `db:"server_id" json:"server_id"`
	MonitorID sql.NullInt32 `db:"monitor_id" json:"monitor_id"`
	Limit     int32         `db:"limit" json:"limit"`
}

func (q *Queries) GetServerLogScoresByMonitorID(ctx context.Context, arg GetServerLogScoresByMonitorIDParams) ([]LogScore, error) {
	rows, err := q.db.QueryContext(ctx, getServerLogScoresByMonitorID, arg.ServerID, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogScore
	for rows.Next() {
		var i LogScore
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.ServerID,
			&i.Ts,
			&i.Score,
			&i.Step,
			&i.Offset,
			&i.Rtt,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServerNetspeed = `-- name: GetServerNetspeed :one
select netspeed from servers where ip = ?
`

func (q *Queries) GetServerNetspeed(ctx context.Context, ip string) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getServerNetspeed, ip)
	var netspeed uint32
	err := row.Scan(&netspeed)
	return netspeed, err
}

const getServerScores = `-- name: GetServerScores :many
select
    m.id, m.hostname, m.tls_name, m.location, m.type,
    ss.score_raw, ss.score_ts, ss.status
  from server_scores ss
    inner join monitors m
      on (m.id=ss.monitor_id)
where
  server_id = ? AND
  monitor_id in (/*SLICE:MonitorIDs*/?)
`

type GetServerScoresParams struct {
	ServerID   uint32   `db:"server_id" json:"server_id"`
	MonitorIDs []uint32 `db:"MonitorIDs" json:"MonitorIDs"`
}

type GetServerScoresRow struct {
	ID       uint32             `db:"id" json:"id"`
	Hostname string             `db:"hostname" json:"hostname"`
	TlsName  sql.NullString     `db:"tls_name" json:"tls_name"`
	Location string             `db:"location" json:"location"`
	Type     MonitorsType       `db:"type" json:"type"`
	ScoreRaw float64            `db:"score_raw" json:"score_raw"`
	ScoreTs  sql.NullTime       `db:"score_ts" json:"score_ts"`
	Status   ServerScoresStatus `db:"status" json:"status"`
}

func (q *Queries) GetServerScores(ctx context.Context, arg GetServerScoresParams) ([]GetServerScoresRow, error) {
	query := getServerScores
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ServerID)
	if len(arg.MonitorIDs) > 0 {
		for _, v := range arg.MonitorIDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:MonitorIDs*/?", strings.Repeat(",?", len(arg.MonitorIDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:MonitorIDs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServerScoresRow
	for rows.Next() {
		var i GetServerScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.TlsName,
			&i.Location,
			&i.Type,
			&i.ScoreRaw,
			&i.ScoreTs,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZoneByName = `-- name: GetZoneByName :one
select id, name, description, parent_id, dns from zones
where
  name = ?
`

func (q *Queries) GetZoneByName(ctx context.Context, name string) (Zone, error) {
	row := q.db.QueryRowContext(ctx, getZoneByName, name)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.Dns,
	)
	return i, err
}

const getZoneCounts = `-- name: GetZoneCounts :many
select id, zone_id, ip_version, date, count_active, count_registered, netspeed_active from zone_server_counts
  where zone_id = ?
  order by date
`

func (q *Queries) GetZoneCounts(ctx context.Context, zoneID uint32) ([]ZoneServerCount, error) {
	rows, err := q.db.QueryContext(ctx, getZoneCounts, zoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ZoneServerCount
	for rows.Next() {
		var i ZoneServerCount
		if err := rows.Scan(
			&i.ID,
			&i.ZoneID,
			&i.IpVersion,
			&i.Date,
			&i.CountActive,
			&i.CountRegistered,
			&i.NetspeedActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZoneStatsData = `-- name: GetZoneStatsData :many
SELECT zc.date, z.name, zc.ip_version, count_active, count_registered, netspeed_active
FROM zone_server_counts zc USE INDEX (date_idx)
  INNER JOIN zones z
    ON(zc.zone_id=z.id)
  WHERE date IN (SELECT max(date) from zone_server_counts)
ORDER BY name
`

type GetZoneStatsDataRow struct {
	Date            time.Time                 `db:"date" json:"date"`
	Name            string                    `db:"name" json:"name"`
	IpVersion       ZoneServerCountsIpVersion `db:"ip_version" json:"ip_version"`
	CountActive     uint32                    `db:"count_active" json:"count_active"`
	CountRegistered uint32                    `db:"count_registered" json:"count_registered"`
	NetspeedActive  uint32                    `db:"netspeed_active" json:"netspeed_active"`
}

func (q *Queries) GetZoneStatsData(ctx context.Context) ([]GetZoneStatsDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getZoneStatsData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetZoneStatsDataRow
	for rows.Next() {
		var i GetZoneStatsDataRow
		if err := rows.Scan(
			&i.Date,
			&i.Name,
			&i.IpVersion,
			&i.CountActive,
			&i.CountRegistered,
			&i.NetspeedActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZoneStatsV2 = `-- name: GetZoneStatsV2 :many
select zone_name, netspeed_active+0 as netspeed_active FROM (
SELECT
	z.name as zone_name,
	SUM(
		IF (deletion_on IS NULL AND score_raw > 10,
			netspeed,
		  0
    )
	) AS netspeed_active
FROM
	servers s
	INNER JOIN server_zones sz ON (sz.server_id = s.id)
	INNER JOIN zones z ON (z.id = sz.zone_id)
  INNER JOIN (
    select zone_id, s.ip_version
    from server_zones sz
      inner join servers s on (s.id=sz.server_id)
    where s.ip=?
  ) as srvz on (srvz.zone_id=z.id AND srvz.ip_version=s.ip_version)
WHERE
	(deletion_on IS NULL OR deletion_on > NOW())
	AND in_pool = 1
	AND netspeed > 0
GROUP BY z.name)
AS server_netspeed
`

type GetZoneStatsV2Row struct {
	ZoneName       string `db:"zone_name" json:"zone_name"`
	NetspeedActive int32  `db:"netspeed_active" json:"netspeed_active"`
}

func (q *Queries) GetZoneStatsV2(ctx context.Context, ip string) ([]GetZoneStatsV2Row, error) {
	rows, err := q.db.QueryContext(ctx, getZoneStatsV2, ip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetZoneStatsV2Row
	for rows.Next() {
		var i GetZoneStatsV2Row
		if err := rows.Scan(&i.ZoneName, &i.NetspeedActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
