// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: query.sql

package ntpdb

import (
	"context"
	"time"
)

const getZoneStatsData = `-- name: GetZoneStatsData :many
SELECT zc.date, z.name, zc.ip_version, count_active, count_registered, netspeed_active
FROM zone_server_counts zc USE INDEX (date_idx)
  INNER JOIN zones z
    ON(zc.zone_id=z.id)
  WHERE date IN (SELECT max(date) from zone_server_counts)
ORDER BY name
`

type GetZoneStatsDataRow struct {
	Date            time.Time                 `json:"date"`
	Name            string                    `json:"name"`
	IpVersion       ZoneServerCountsIpVersion `json:"ip_version"`
	CountActive     uint32                    `json:"count_active"`
	CountRegistered uint32                    `json:"count_registered"`
	NetspeedActive  uint32                    `json:"netspeed_active"`
}

func (q *Queries) GetZoneStatsData(ctx context.Context) ([]GetZoneStatsDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getZoneStatsData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetZoneStatsDataRow
	for rows.Next() {
		var i GetZoneStatsDataRow
		if err := rows.Scan(
			&i.Date,
			&i.Name,
			&i.IpVersion,
			&i.CountActive,
			&i.CountRegistered,
			&i.NetspeedActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
