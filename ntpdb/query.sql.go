// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package ntpdb

import (
	"context"
	"time"
)

const getServerByID = `-- name: GetServerByID :one
select id, ip, ip_version, user_id, account_id, hostname, stratum, in_pool, in_server_list, netspeed, created_on, updated_on, score_ts, score_raw, deletion_on from servers
where
  id = ?
`

func (q *Queries) GetServerByID(ctx context.Context, id uint32) (Server, error) {
	row := q.db.QueryRowContext(ctx, getServerByID, id)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.IpVersion,
		&i.UserID,
		&i.AccountID,
		&i.Hostname,
		&i.Stratum,
		&i.InPool,
		&i.InServerList,
		&i.Netspeed,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ScoreTs,
		&i.ScoreRaw,
		&i.DeletionOn,
	)
	return i, err
}

const getServerByIP = `-- name: GetServerByIP :one
select id, ip, ip_version, user_id, account_id, hostname, stratum, in_pool, in_server_list, netspeed, created_on, updated_on, score_ts, score_raw, deletion_on from servers
where
  ip = ?
`

func (q *Queries) GetServerByIP(ctx context.Context, ip string) (Server, error) {
	row := q.db.QueryRowContext(ctx, getServerByIP, ip)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.IpVersion,
		&i.UserID,
		&i.AccountID,
		&i.Hostname,
		&i.Stratum,
		&i.InPool,
		&i.InServerList,
		&i.Netspeed,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ScoreTs,
		&i.ScoreRaw,
		&i.DeletionOn,
	)
	return i, err
}

const getServerNetspeed = `-- name: GetServerNetspeed :one
select netspeed from servers where ip = ?
`

func (q *Queries) GetServerNetspeed(ctx context.Context, ip string) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getServerNetspeed, ip)
	var netspeed uint32
	err := row.Scan(&netspeed)
	return netspeed, err
}

const getZoneStatsData = `-- name: GetZoneStatsData :many
SELECT zc.date, z.name, zc.ip_version, count_active, count_registered, netspeed_active
FROM zone_server_counts zc USE INDEX (date_idx)
  INNER JOIN zones z
    ON(zc.zone_id=z.id)
  WHERE date IN (SELECT max(date) from zone_server_counts)
ORDER BY name
`

type GetZoneStatsDataRow struct {
	Date            time.Time                 `db:"date" json:"date"`
	Name            string                    `db:"name" json:"name"`
	IpVersion       ZoneServerCountsIpVersion `db:"ip_version" json:"ip_version"`
	CountActive     uint32                    `db:"count_active" json:"count_active"`
	CountRegistered uint32                    `db:"count_registered" json:"count_registered"`
	NetspeedActive  uint32                    `db:"netspeed_active" json:"netspeed_active"`
}

func (q *Queries) GetZoneStatsData(ctx context.Context) ([]GetZoneStatsDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getZoneStatsData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetZoneStatsDataRow
	for rows.Next() {
		var i GetZoneStatsDataRow
		if err := rows.Scan(
			&i.Date,
			&i.Name,
			&i.IpVersion,
			&i.CountActive,
			&i.CountRegistered,
			&i.NetspeedActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZoneStatsV2 = `-- name: GetZoneStatsV2 :many
select zone_name, netspeed_active+0 as netspeed_active FROM (
SELECT
	z.name as zone_name,
	SUM(
		IF (deletion_on IS NULL AND score_raw > 10,
			netspeed,
		  0
    )
	) AS netspeed_active
FROM
	servers s
	INNER JOIN server_zones sz ON (sz.server_id = s.id)
	INNER JOIN zones z ON (z.id = sz.zone_id)
  INNER JOIN (
    select zone_id, s.ip_version
    from server_zones sz
      inner join servers s on (s.id=sz.server_id)
    where s.ip=?
  ) as srvz on (srvz.zone_id=z.id AND srvz.ip_version=s.ip_version)
WHERE
	(deletion_on IS NULL OR deletion_on > NOW())
	AND in_pool = 1
	AND netspeed > 0
GROUP BY z.name)
AS server_netspeed
`

type GetZoneStatsV2Row struct {
	ZoneName       string `db:"zone_name" json:"zone_name"`
	NetspeedActive int32  `db:"netspeed_active" json:"netspeed_active"`
}

func (q *Queries) GetZoneStatsV2(ctx context.Context, ip string) ([]GetZoneStatsV2Row, error) {
	rows, err := q.db.QueryContext(ctx, getZoneStatsV2, ip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetZoneStatsV2Row
	for rows.Next() {
		var i GetZoneStatsV2Row
		if err := rows.Scan(&i.ZoneName, &i.NetspeedActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
